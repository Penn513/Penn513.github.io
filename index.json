[{"categories":["Data Structures and Algorithms"],"content":"并查集(Disjoint-Set)是一种可以动态维护若干个不重叠的集合，并支持合并与查询两种操作的一种数据结构。","date":"2021-07-15","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 并查集","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["Data Structures and Algorithms"],"content":"上概念 并查集： Disjoint-Set，是用于处理一些不交集的合并及查询问题的一种数据结构，支持查询、合并以及添加操作。 合并： Union，简单来说，就是把有关联的节点视为一个集群，每个集群用一个祖宗节点来表示。 查询： Find，指的是依次查找某个节点的父节点，直至祖宗节点。 路径压缩： 随着节点的加入，族谱层级可能会很深，这样查找效率很低。因此可以在由下至上查询的过程中，让当前向上移动，进而降低族谱层级，这就是路径压缩，单词操作复杂度为O(logN)。 ","date":"2021-07-15","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 并查集","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["Data Structures and Algorithms"],"content":"上代码 class DisjointSet(object): \"并查集\" def __init__(self, n): \"\"\" parent[i]表示节点i的父节点，初始化parent[i] = i，即每个节点的父节点均为自己 rank[i]表示当前节点的后代层数，包括自己 \"\"\" self.parent = list(range(n)) self.rank = [1] * n def get_root(self, i): if self.parent[i] != self.parent[self.parent[i]]: self.parent[i] = self.get_root(self.parent[i]) return self.parent[i] def is_connected(self, i, j): return self.get_root(i) == self.get_root(j) def union(self, i, j): i_root = self.get_root(i) j_root = self.get_root(j) # 合并的时候，将层数少的树连接到层数多的树，以减少合并树的高度 if self.rank[i_root] == self.rank[j_root]: self.parent[i_root] = j_root self.rank[j_root] += 1 elif self.rank[i_root] \u003e self.rank[j_root]: self.parent[j_root] = i_root else: self.parent[i_root] = j_root ","date":"2021-07-15","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 并查集","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 朋友圈（省份数量）https://leetcode-cn.com/problems/number-of-provinces/ 省份数量\r class DisjointSet: \"并查集\" def __init__(self, n): \"\"\" parent[i]表示节点i的父节点，初始化parent[i] = i，即每个节点的父节点均为自己 rank[i]表示当前节点的后代层数，包括自己 \"\"\" self.parent = list(range(n)) self.rank = [1] * n self.num_of_sets = n def get_root(self, i): if self.parent[i] != self.parent[self.parent[i]]: self.parent[i] = self.get_root(self.parent[i]) return self.parent[i] def is_connected(self, i, j): return self.get_root(i) == self.get_root(j) def union(self, i, j): i_root = self.get_root(i) j_root = self.get_root(j) # 合并的时候，将层数少的树连接到层数多的树，以减少合并树的高度 if self.rank[i_root] == self.rank[j_root]: self.parent[i_root] = j_root self.rank[j_root] += 1 elif self.rank[i_root] \u003e self.rank[j_root]: self.parent[j_root] = i_root else: self.parent[i_root] = j_root self.num_of_sets -= 1 def add(self, x): if x not in self.parent: self.parent[x] = None class Solution: def findCircleNum(self, isConnected: List[List[int]]) -\u003e int: uf = DisjointSet(len(isConnected)) for i in range(len(isConnected)): for j in range(i): if isConnected[i][j] and not uf.is_connected(i, j): uf.union(i, j) return uf.num_of_sets ","date":"2021-07-15","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 并查集","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["Linux"],"content":"perf_events is an event-oriented observability tool, which can help you solve advanced performance and troubleshooting functions","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"perf也被称为perf_events，是一个面向event的观察工具，可用于性能剖析或内核故障排查。perf是内核的一部分，随内核发布。 ","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:0","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"事件（Events）事件分类： Hardware Events: CPU performance monitoring counters. Software Events: These are low level events based on kernel counters. For example, CPU migrations, minor faults, major faults, etc. Kernel Tracepoint Events: This are static kernel-level instrumentation points that are hardcoded in interesting and logical places in the kernel. User Statically-Defined Tracing (USDT): These are static tracepoints for user-level programs and applications. Dynamic Tracing: Software can be dynamically instrumented, creating events in any location. For kernel software, this uses the kprobes framework. For user-level software, uprobes. Timed Profiling: Snapshots can be collected at an arbitrary frequency, using perf record -FHz. This is commonly used for CPU usage profiling, and works by creating custom timed interrupt events. # perf list List of pre-defined events (to be used in -e): cpu-cycles OR cycles [Hardware event] instructions [Hardware event] cache-references [Hardware event] cache-misses [Hardware event] branch-instructions OR branches [Hardware event] branch-misses [Hardware event] bus-cycles [Hardware event] stalled-cycles-frontend OR idle-cycles-frontend [Hardware event] stalled-cycles-backend OR idle-cycles-backend [Hardware event] ref-cycles [Hardware event] cpu-clock [Software event] task-clock [Software event] page-faults OR faults [Software event] context-switches OR cs [Software event] cpu-migrations OR migrations [Software event] minor-faults [Software event] major-faults [Software event] alignment-faults [Software event] emulation-faults [Software event] L1-dcache-loads [Hardware cache event] L1-dcache-load-misses [Hardware cache event] L1-dcache-stores [Hardware cache event] [...] rNNN [Raw hardware event descriptor] cpu/t1=v1[,t2=v2,t3 ...]/modifier [Raw hardware event descriptor] (see 'man perf-list' on how to encode it) mem:\u003caddr\u003e[:access] [Hardware breakpoint] probe:tcp_sendmsg [Tracepoint event] [...] sched:sched_process_exec [Tracepoint event] sched:sched_process_fork [Tracepoint event] sched:sched_process_wait [Tracepoint event] sched:sched_wait_task [Tracepoint event] sched:sched_process_exit [Tracepoint event] [...] # perf list | wc -l 657 ","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:1","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"示例最近遇到个问题，程序的所有线程都被绑到0核上，但运行时并未使用taskset绑核。linux的绑核是通过系统调用syscalls:sys_enter_sched_setaffinity，进而考虑使用perf跟踪该系统调用，查看调用栈。 # 开启事件跟踪 perf record -g -e \"syscalls:sys_enter_sched_setaffinity\" -a # 另开启一个session，运行程序 # 通过Ctrl+c结束perf，在当前路径生成perf.data # 查看调用栈 perf script ","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:2","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"命令列出事件Listing Events # Listing all currently known events: perf list # Listing sched tracepoints: perf list 'sched:*' 计数事件Counting Events # CPU counter statistics for the specified command: perf stat command # Detailed CPU counter statistics (includes extras) for the specified command: perf stat -d command # CPU counter statistics for the specified PID, until Ctrl-C: perf stat -p PID # CPU counter statistics for the entire system, for 5 seconds: perf stat -a sleep 5 # Various basic CPU statistics, system wide, for 10 seconds: perf stat -e cycles,instructions,cache-references,cache-misses,bus-cycles -a sleep 10 # Various CPU level 1 data cache statistics for the specified command: perf stat -e L1-dcache-loads,L1-dcache-load-misses,L1-dcache-stores command # Various CPU data TLB statistics for the specified command: perf stat -e dTLB-loads,dTLB-load-misses,dTLB-prefetch-misses command # Various CPU last level cache statistics for the specified command: perf stat -e LLC-loads,LLC-load-misses,LLC-stores,LLC-prefetches command # Using raw PMC counters, eg, counting unhalted core cycles: perf stat -e r003c -a sleep 5 # PMCs: counting cycles and frontend stalls via raw specification: perf stat -e cycles -e cpu/event=0x0e,umask=0x01,inv,cmask=0x01/ -a sleep 5 # Count syscalls per-second system-wide: perf stat -e raw_syscalls:sys_enter -I 1000 -a # Count system calls by type for the specified PID, until Ctrl-C: perf stat -e 'syscalls:sys_enter_*' -p PID # Count system calls by type for the entire system, for 5 seconds: perf stat -e 'syscalls:sys_enter_*' -a sleep 5 # Count scheduler events for the specified PID, until Ctrl-C: perf stat -e 'sched:*' -p PID # Count scheduler events for the specified PID, for 10 seconds: perf stat -e 'sched:*' -p PID sleep 10 # Count ext4 events for the entire system, for 10 seconds: perf stat -e 'ext4:*' -a sleep 10 # Count block device I/O events for the entire system, for 10 seconds: perf stat -e 'block:*' -a sleep 10 # Count all vmscan events, printing a report every second: perf stat -e 'vmscan:*' -a -I 1000 性能剖析Profiling # Sample on-CPU functions for the specified command, at 99 Hertz: perf record -F 99 command # Sample on-CPU functions for the specified PID, at 99 Hertz, until Ctrl-C: perf record -F 99 -p PID # Sample on-CPU functions for the specified PID, at 99 Hertz, for 10 seconds: perf record -F 99 -p PID sleep 10 # Sample CPU stack traces (via frame pointers) for the specified PID, at 99 Hertz, for 10 seconds: perf record -F 99 -p PID -g -- sleep 10 # Sample CPU stack traces for the PID, using dwarf (dbg info) to unwind stacks, at 99 Hertz, for 10 seconds: perf record -F 99 -p PID --call-graph dwarf sleep 10 # Sample CPU stack traces for the entire system, at 99 Hertz, for 10 seconds (\u003c Linux 4.11): perf record -F 99 -ag -- sleep 10 # Sample CPU stack traces for the entire system, at 99 Hertz, for 10 seconds (\u003e= Linux 4.11): perf record -F 99 -g -- sleep 10 # If the previous command didn't work, try forcing perf to use the cpu-clock event: perf record -F 99 -e cpu-clock -ag -- sleep 10 # Sample CPU stack traces for a container identified by its /sys/fs/cgroup/perf_event cgroup: perf record -F 99 -e cpu-clock --cgroup=docker/1d567f4393190204...etc... -a -- sleep 10 # Sample CPU stack traces for the entire system, with dwarf stacks, at 99 Hertz, for 10 seconds: perf record -F 99 -a --call-graph dwarf sleep 10 # Sample CPU stack traces for the entire system, using last branch record for stacks, ... (\u003e= Linux 4.?): perf record -F 99 -a --call-graph lbr sleep 10 # Sample CPU stack traces, once every 10,000 Level 1 data cache misses, for 5 seconds: perf record -e L1-dcache-load-misses -c 10000 -ag -- sleep 5 # Sample CPU stack traces, once every 100 last level cache misses, for 5 seconds: perf record -e LLC-load-misses -c 100 -ag -- sleep 5 # Sample on-CPU kernel instructions, for 5 seconds: perf record -e cycles:k -a -- sleep 5 # Sample on-CPU user instructions, for 5 seconds: perf record -e cycle","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:3","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"参考https://www.brendangregg.com/perf.html ","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:4","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Data Structures and Algorithms"],"content":"数据排列具有单调性的栈。","date":"2021-07-12","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["Data Structures and Algorithms"],"content":"性质 单调递减栈，能表示入栈元素左边第一个比它大的元素。入栈表明本身比栈顶小，出栈表面本身比栈顶大； 单调递增栈，能表示入栈元素左边第一个比它小的元素。入栈表明本身比栈顶大，出栈表面本身比栈顶小； ","date":"2021-07-12","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 接雨水https://leetcode-cn.com/problems/trapping-rain-water/ 接雨水\r class Solution: def trap(self, height: List[int]) -\u003e int: if len(height) == 0: return 0 sumArea = 0 stack = [] for right in range(len(height)): while stack and height[stack[-1]] \u003c height[right]: if len(stack) \u003e= 2: bottom = stack.pop() left = stack[-1] waterHeight = min(height[right], height[left]) - height[bottom] waterWidth = right - left - 1 currArea = waterHeight*waterWidth sumArea += currArea else: stack.pop() stack.append(right) return sumArea ","date":"2021-07-12","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["Data Structures and Algorithms"],"content":"例题 2 - 股票价格跨度https://leetcode-cn.com/problems/online-stock-span/ 股票跨度\r 股票跨度-单调递减栈\r class StockSpanner: def __init__(self): self.stack = [] def next(self, price: int) -\u003e int: if not self.stack or self.stack[-1][0] \u003e price: self.stack.append((price, 1)) return 1 ans = 1 while self.stack and self.stack[-1][0] \u003c= price: bottom = self.stack.pop() ans += bottom[1] self.stack.append((price, ans)) return ans # Your StockSpanner object will be instantiated and called as such: # obj = StockSpanner() # param_1 = obj.next(price) ","date":"2021-07-12","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"}]