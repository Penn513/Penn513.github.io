[{"categories":["Data Structures and Algorithms"],"content":"并查集(Disjoint-Set)是一种可以动态维护若干个不重叠的集合，并支持合并与查询两种操作的一种数据结构。","date":"2021-07-15","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 并查集","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["Data Structures and Algorithms"],"content":"概念 并查集： Disjoint-Set，是用于处理一些不交集的合并及查询问题的一种数据结构，支持查询、合并以及添加操作。 合并： Union，简单来说，就是把有关联的节点视为一个集群，每个集群用一个祖宗节点来表示。 查询： Find，指的是依次查找某个节点的父节点，直至祖宗节点。 路径压缩： 随着节点的加入，族谱层级可能会很深，这样查找效率很低。因此可以在由下至上查询的过程中，让当前向上移动，进而降低族谱层级，这就是路径压缩，单词操作复杂度为O(logN)。 ","date":"2021-07-15","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 并查集","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["Data Structures and Algorithms"],"content":"代码模板 class DisjointSet(object): \"并查集\" def __init__(self, n): \"\"\" parent[i]表示节点i的父节点，初始化parent[i] = i，即每个节点的父节点均为自己 rank[i]表示当前节点的后代层数，包括自己 \"\"\" self.parent = list(range(n)) self.rank = [1] * n def get_root(self, i): if self.parent[i] != self.parent[self.parent[i]]: self.parent[i] = self.get_root(self.parent[i]) return self.parent[i] def is_connected(self, i, j): return self.get_root(i) == self.get_root(j) def union(self, i, j): i_root = self.get_root(i) j_root = self.get_root(j) # 合并的时候，将层数少的树连接到层数多的树，以减少合并树的高度 if self.rank[i_root] == self.rank[j_root]: self.parent[i_root] = j_root self.rank[j_root] += 1 elif self.rank[i_root] \u003e self.rank[j_root]: self.parent[j_root] = i_root else: self.parent[i_root] = j_root ","date":"2021-07-15","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 并查集","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 朋友圈（省份数量）https://leetcode-cn.com/problems/number-of-provinces/ 省份数量\r class DisjointSet: \"并查集\" def __init__(self, n): \"\"\" parent[i]表示节点i的父节点，初始化parent[i] = i，即每个节点的父节点均为自己 rank[i]表示当前节点的后代层数，包括自己 \"\"\" self.parent = list(range(n)) self.rank = [1] * n self.num_of_sets = n def get_root(self, i): if self.parent[i] != self.parent[self.parent[i]]: self.parent[i] = self.get_root(self.parent[i]) return self.parent[i] def is_connected(self, i, j): return self.get_root(i) == self.get_root(j) def union(self, i, j): i_root = self.get_root(i) j_root = self.get_root(j) # 合并的时候，将层数少的树连接到层数多的树，以减少合并树的高度 if self.rank[i_root] == self.rank[j_root]: self.parent[i_root] = j_root self.rank[j_root] += 1 elif self.rank[i_root] \u003e self.rank[j_root]: self.parent[j_root] = i_root else: self.parent[i_root] = j_root self.num_of_sets -= 1 def add(self, x): if x not in self.parent: self.parent[x] = None class Solution: def findCircleNum(self, isConnected: List[List[int]]) -\u003e int: uf = DisjointSet(len(isConnected)) for i in range(len(isConnected)): for j in range(i): if isConnected[i][j] and not uf.is_connected(i, j): uf.union(i, j) return uf.num_of_sets ","date":"2021-07-15","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 并查集","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["Data Structures and Algorithms"],"content":"例题 2 - 岛屿数量https://leetcode-cn.com/problems/number-of-islands/ 岛屿数量\r class DisjointSet: \"并查集\" def __init__(self, n): \"\"\" parent[i]表示节点i的父节点，初始化parent[i] = i，即每个节点的父节点均为自己 rank[i]表示当前节点的后代层数，包括自己 \"\"\" self.parent = list(range(n)) self.rank = [1] * n self.num_of_sets = n def get_root(self, i): if self.parent[i] != self.parent[self.parent[i]]: self.parent[i] = self.get_root(self.parent[i]) return self.parent[i] def is_connected(self, i, j): return self.get_root(i) == self.get_root(j) def union(self, i, j): i_root = self.get_root(i) j_root = self.get_root(j) # 若两个节点在同一集合中，跳过 if i_root == j_root: return # 合并的时候，将层数少的树连接到层数多的树，以减少合并树的高度 if self.rank[i_root] == self.rank[j_root]: self.parent[i_root] = j_root self.rank[j_root] += 1 elif self.rank[i_root] \u003e self.rank[j_root]: self.parent[j_root] = i_root else: self.parent[i_root] = j_root self.num_of_sets -= 1 def add(self, x): if x not in self.parent: self.parent[x] = None class Solution: def numIslands(self, grid: List[List[str]]) -\u003e int: m, n = len(grid), len(grid[0]) uf = DisjointSet(m*n) # i*num_col + j 作为唯一标识 for i in range(m): for j in range(n): if grid[i][j] == \"0\": uf.num_of_sets -= 1 continue if j + 1 \u003c n and grid[i][j + 1] == \"1\": uf.union(i*n + j, i*n + j + 1) if i + 1 \u003c m and grid[i + 1][j] == \"1\": uf.union(i*n + j, (i + 1)*n + j) return uf.num_of_sets ","date":"2021-07-15","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/:0:4","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 并查集","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["Data Structures and Algorithms"],"content":"例题 3 - 尽量减少恶意软件的传播https://leetcode-cn.com/problems/minimize-malware-spread/ 恶意软件传播\r class DisjointSet(object): \"并查集\" def __init__(self, n): \"\"\" parent[i]表示节点i的父节点，初始化parent[i] = i，即每个节点的父节点均为自己 rank[i]表示当前节点的后代层数，包括自己 \"\"\" self.parent = list(range(n)) # 记录每棵树高度，用于优化合并查找效率 self.rank = [1] * n # 记录每棵树中的传播源数量，这题里传播源数量大于1时，减少一个源并无效 self.num_of_source = [0] * n # 记录每课树的节点树，判断可能传播的节点数量 self.num_of_node = [1] * n def get_root(self, i): if self.parent[i] != self.parent[self.parent[i]]: self.parent[i] = self.get_root(self.parent[i]) return self.parent[i] def is_connected(self, i, j): return self.get_root(i) == self.get_root(j) def union(self, i, j): i_root = self.get_root(i) j_root = self.get_root(j) # 合并的时候，将层数少的树连接到层数多的树，以减少合并树的高度 if self.rank[i_root] == self.rank[j_root]: self.parent[i_root] = j_root self.rank[j_root] += 1 elif self.rank[i_root] \u003e self.rank[j_root]: self.parent[j_root] = i_root else: self.parent[i_root] = j_root self.num_of_node[i_root] += 1 self.num_of_node[j_root] += 1 class Solution: def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -\u003e int: uf = DisjointSet(len(graph)) for i in range(len(graph)): for j in range(i): if graph[i][j]: uf.union(i, j) for _, v in enumerate(initial): uf.num_of_source[uf.get_root(v)] += 1 # 效果相同时返回索引小的节点，用例里并非顺序排列，因此先排序 initial.sort() res = initial[0] max_virus = 0 for k in initial: root = uf.get_root(k) if uf.num_of_source[root] == 1 and uf.num_of_node[root] \u003e max_virus: max_virus = uf.num_of_node[root] res = k return res ","date":"2021-07-15","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/:0:5","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 并查集","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["Linux"],"content":"perf_events is an event-oriented observability tool, which can help you solve advanced performance and troubleshooting functions","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"perf也被称为perf_events，是一个面向event的观察工具，可用于性能剖析或内核故障排查。perf是内核的一部分，随内核发布。 ","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:0","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"事件（Events）事件分类： Hardware Events: CPU performance monitoring counters. Software Events: These are low level events based on kernel counters. For example, CPU migrations, minor faults, major faults, etc. Kernel Tracepoint Events: This are static kernel-level instrumentation points that are hardcoded in interesting and logical places in the kernel. User Statically-Defined Tracing (USDT): These are static tracepoints for user-level programs and applications. Dynamic Tracing: Software can be dynamically instrumented, creating events in any location. For kernel software, this uses the kprobes framework. For user-level software, uprobes. Timed Profiling: Snapshots can be collected at an arbitrary frequency, using perf record -FHz. This is commonly used for CPU usage profiling, and works by creating custom timed interrupt events. # perf list List of pre-defined events (to be used in -e): cpu-cycles OR cycles [Hardware event] instructions [Hardware event] cache-references [Hardware event] cache-misses [Hardware event] branch-instructions OR branches [Hardware event] branch-misses [Hardware event] bus-cycles [Hardware event] stalled-cycles-frontend OR idle-cycles-frontend [Hardware event] stalled-cycles-backend OR idle-cycles-backend [Hardware event] ref-cycles [Hardware event] cpu-clock [Software event] task-clock [Software event] page-faults OR faults [Software event] context-switches OR cs [Software event] cpu-migrations OR migrations [Software event] minor-faults [Software event] major-faults [Software event] alignment-faults [Software event] emulation-faults [Software event] L1-dcache-loads [Hardware cache event] L1-dcache-load-misses [Hardware cache event] L1-dcache-stores [Hardware cache event] [...] rNNN [Raw hardware event descriptor] cpu/t1=v1[,t2=v2,t3 ...]/modifier [Raw hardware event descriptor] (see 'man perf-list' on how to encode it) mem:\u003caddr\u003e[:access] [Hardware breakpoint] probe:tcp_sendmsg [Tracepoint event] [...] sched:sched_process_exec [Tracepoint event] sched:sched_process_fork [Tracepoint event] sched:sched_process_wait [Tracepoint event] sched:sched_wait_task [Tracepoint event] sched:sched_process_exit [Tracepoint event] [...] # perf list | wc -l 657 ","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:1","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"示例最近遇到个问题，程序的所有线程都被绑到0核上，但运行时并未使用taskset绑核。linux的绑核是通过系统调用syscalls:sys_enter_sched_setaffinity，进而考虑使用perf跟踪该系统调用，查看调用栈。 # 开启事件跟踪 perf record -g -e \"syscalls:sys_enter_sched_setaffinity\" -a # 另开启一个session，运行程序 # 通过Ctrl+c结束perf，在当前路径生成perf.data # 查看调用栈 perf script ","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:2","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"命令列出事件Listing Events # Listing all currently known events: perf list # Listing sched tracepoints: perf list 'sched:*' 计数事件Counting Events # CPU counter statistics for the specified command: perf stat command # Detailed CPU counter statistics (includes extras) for the specified command: perf stat -d command # CPU counter statistics for the specified PID, until Ctrl-C: perf stat -p PID # CPU counter statistics for the entire system, for 5 seconds: perf stat -a sleep 5 # Various basic CPU statistics, system wide, for 10 seconds: perf stat -e cycles,instructions,cache-references,cache-misses,bus-cycles -a sleep 10 # Various CPU level 1 data cache statistics for the specified command: perf stat -e L1-dcache-loads,L1-dcache-load-misses,L1-dcache-stores command # Various CPU data TLB statistics for the specified command: perf stat -e dTLB-loads,dTLB-load-misses,dTLB-prefetch-misses command # Various CPU last level cache statistics for the specified command: perf stat -e LLC-loads,LLC-load-misses,LLC-stores,LLC-prefetches command # Using raw PMC counters, eg, counting unhalted core cycles: perf stat -e r003c -a sleep 5 # PMCs: counting cycles and frontend stalls via raw specification: perf stat -e cycles -e cpu/event=0x0e,umask=0x01,inv,cmask=0x01/ -a sleep 5 # Count syscalls per-second system-wide: perf stat -e raw_syscalls:sys_enter -I 1000 -a # Count system calls by type for the specified PID, until Ctrl-C: perf stat -e 'syscalls:sys_enter_*' -p PID # Count system calls by type for the entire system, for 5 seconds: perf stat -e 'syscalls:sys_enter_*' -a sleep 5 # Count scheduler events for the specified PID, until Ctrl-C: perf stat -e 'sched:*' -p PID # Count scheduler events for the specified PID, for 10 seconds: perf stat -e 'sched:*' -p PID sleep 10 # Count ext4 events for the entire system, for 10 seconds: perf stat -e 'ext4:*' -a sleep 10 # Count block device I/O events for the entire system, for 10 seconds: perf stat -e 'block:*' -a sleep 10 # Count all vmscan events, printing a report every second: perf stat -e 'vmscan:*' -a -I 1000 性能剖析Profiling # Sample on-CPU functions for the specified command, at 99 Hertz: perf record -F 99 command # Sample on-CPU functions for the specified PID, at 99 Hertz, until Ctrl-C: perf record -F 99 -p PID # Sample on-CPU functions for the specified PID, at 99 Hertz, for 10 seconds: perf record -F 99 -p PID sleep 10 # Sample CPU stack traces (via frame pointers) for the specified PID, at 99 Hertz, for 10 seconds: perf record -F 99 -p PID -g -- sleep 10 # Sample CPU stack traces for the PID, using dwarf (dbg info) to unwind stacks, at 99 Hertz, for 10 seconds: perf record -F 99 -p PID --call-graph dwarf sleep 10 # Sample CPU stack traces for the entire system, at 99 Hertz, for 10 seconds (\u003c Linux 4.11): perf record -F 99 -ag -- sleep 10 # Sample CPU stack traces for the entire system, at 99 Hertz, for 10 seconds (\u003e= Linux 4.11): perf record -F 99 -g -- sleep 10 # If the previous command didn't work, try forcing perf to use the cpu-clock event: perf record -F 99 -e cpu-clock -ag -- sleep 10 # Sample CPU stack traces for a container identified by its /sys/fs/cgroup/perf_event cgroup: perf record -F 99 -e cpu-clock --cgroup=docker/1d567f4393190204...etc... -a -- sleep 10 # Sample CPU stack traces for the entire system, with dwarf stacks, at 99 Hertz, for 10 seconds: perf record -F 99 -a --call-graph dwarf sleep 10 # Sample CPU stack traces for the entire system, using last branch record for stacks, ... (\u003e= Linux 4.?): perf record -F 99 -a --call-graph lbr sleep 10 # Sample CPU stack traces, once every 10,000 Level 1 data cache misses, for 5 seconds: perf record -e L1-dcache-load-misses -c 10000 -ag -- sleep 5 # Sample CPU stack traces, once every 100 last level cache misses, for 5 seconds: perf record -e LLC-load-misses -c 100 -ag -- sleep 5 # Sample on-CPU kernel instructions, for 5 seconds: perf record -e cycles:k -a -- sleep 5 # Sample on-CPU user instructions, for 5 seconds: perf record -e cycle","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:3","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"参考https://www.brendangregg.com/perf.html ","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:4","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Data Structures and Algorithms"],"content":"数据排列具有单调性的栈。","date":"2021-07-12","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["Data Structures and Algorithms"],"content":"性质 单调递减栈，能表示入栈元素左边第一个比它大的元素。入栈表明本身比栈顶小，出栈表面本身比栈顶大； 单调递增栈，能表示入栈元素左边第一个比它小的元素。入栈表明本身比栈顶大，出栈表面本身比栈顶小； ","date":"2021-07-12","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 接雨水https://leetcode-cn.com/problems/trapping-rain-water/ 接雨水\r class Solution: def trap(self, height: List[int]) -\u003e int: if len(height) == 0: return 0 sumArea = 0 stack = [] for right in range(len(height)): while stack and height[stack[-1]] \u003c height[right]: if len(stack) \u003e= 2: bottom = stack.pop() left = stack[-1] waterHeight = min(height[right], height[left]) - height[bottom] waterWidth = right - left - 1 currArea = waterHeight*waterWidth sumArea += currArea else: stack.pop() stack.append(right) return sumArea ","date":"2021-07-12","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["Data Structures and Algorithms"],"content":"例题 2 - 股票价格跨度https://leetcode-cn.com/problems/online-stock-span/ 股票跨度\r 股票跨度-单调递减栈\r class StockSpanner: def __init__(self): self.stack = [] def next(self, price: int) -\u003e int: if not self.stack or self.stack[-1][0] \u003e price: self.stack.append((price, 1)) return 1 ans = 1 while self.stack and self.stack[-1][0] \u003c= price: bottom = self.stack.pop() ans += bottom[1] self.stack.append((price, ans)) return ans # Your StockSpanner object will be instantiated and called as such: # obj = StockSpanner() # param_1 = obj.next(price) ","date":"2021-07-12","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["Data Structures and Algorithms"],"content":"数据结构与算法 - 滑动窗口。","date":"2021-07-12","objectID":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 滑动窗口","uri":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"categories":["Data Structures and Algorithms"],"content":"简介提到滑动窗口，最先想到的是TCP的流量控制，这里可以用来解决一些查找满足一定条件的连续区间的问题。 例子，给定数组为[2,3,1,2,4,3]，查找长度最小子数组，满足最小和s为7。当然可以枚举所有子数组求和，但会有很多重复计算，时间复杂度为O(N^2)，这里使用滑动窗口优化算法。 实现，给定一个滑动窗口，左右端分别为L和R，起始位置均为数组最左端。首先移动R，直至窗口区间满足给定条件，然后移动L，至区间不满足条件，再移动R。如此往复，并在过程中记录最优值。 ","date":"2021-07-12","objectID":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 滑动窗口","uri":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"categories":["Data Structures and Algorithms"],"content":"代码模板 def findSubArray(nums): N = len(nums) # 数组/字符串长度 left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间 sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数 res = 0 # 保存最大的满足题目要求的 子数组/子串 长度 while right \u003c N: # 当右边的指针没有搜索到 数组/字符串 的结尾 sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数 while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间 sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数 left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反 # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串 res = max(res, right - left + 1) # 需要更新结果 right += 1 # 移动右指针，去探索新的区间 return res 作者：fuxuemingzhu 链接：https://leetcode-cn.com/problems/get-equal-substrings-within-budget/solution/fen-xiang-zhen-cang-de-hua-dong-chuang-k-e3rd/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-07-12","objectID":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 滑动窗口","uri":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 尽可能使字符串相等https://leetcode-cn.com/problems/get-equal-substrings-within-budget/ 尽可能使字符串相等\r class Solution: def equalSubstring(self, s: str, t: str, maxCost: int) -\u003e int: N = len(s) if N == 0: return 0 costs = [abs(ord(s[i]) - ord(t[i])) for i in range(N)] left, right = 0, 0 cost = 0 max_len = 0 while right \u003c N: cost += costs[right] while cost \u003e maxCost: cost -= costs[left] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len ","date":"2021-07-12","objectID":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 滑动窗口","uri":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"categories":["Data Structures and Algorithms"],"content":"例题 2 - 滑动窗口最大值https://leetcode-cn.com/problems/sliding-window-maximum/ 滑动窗口最大值\r class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -\u003e List[int]: ''' 思路: 1. 利用双端队列记录当前滑动窗口的元素索引 2. 队列最左侧元素记录滑动窗口中最大元素的索引 3. 遍历数组： - 如果队列最左侧索引已不在滑动窗口范围内，弹出队列最左侧索引 - 通过循环确保队列的最左侧索引所对应元素值最大 - 新元素入队 - 从第一个滑动窗口的末尾索引开始将最大值存储到结果res中 ''' res = [] dq = deque() for i, v in enumerate(nums): if dq and dq[0] \u003c i - k + 1: dq.popleft() while dq and nums[dq[-1]] \u003c v: dq.pop() dq.append(i) if i \u003e= k - 1: res.append(nums[dq[0]]) return res ","date":"2021-07-12","objectID":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:4","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 滑动窗口","uri":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"categories":["Data Structures and Algorithms"],"content":"例题 3 - 串联所有单词的子串https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/ 串联所有单词的子串\r 这题最秀的地方不是滑动窗口，是如何判断子串是否满足条件。可以用两个 HashMap 来解决。 首先，我们把所有的单词存到 HashMap 里，key 直接存单词，value 存单词出现的个数（因为给出的单词可能会有重复的，所以可能是 1 或 2 或者其他）。然后扫描子串的单词，如果当前扫描的单词在之前的 HashMap 中，就把该单词存到新的 HashMap 中，并判断新的 HashMap 中该单词的 value 是不是大于之前的 HashMap 该单词的 value ，如果大了，就代表该子串不是我们要找的，接着判断下一个子串就可以了。如果不大于，那么我们接着判断下一个单词的情况。子串扫描结束，如果子串的全部单词都符合，那么该子串就是我们找的其中一个。 参考： https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-6/ class Solution: def findSubstring(self, s: str, words: List[str]) -\u003e List[int]: if not s or not words: return [] n = len(s) one_word_len = len(words[0]) word_cnt = len(words) all_len = one_word_len * word_cnt words_cnt = defaultdict(int) # 给定words的词数表 for w in words: words_cnt[w] += 1 res = [] for i in range(one_word_len): # 外层对一个单词长度循环，这里需要思考下， # 窗口给按单词长度滑动，这样可以覆盖所有情况 cur_w_num = 0 # 单词个数 L, R = i, i cur_w_dic = defaultdict(int) # 当前单词的次数统计 while R + one_word_len \u003c= len(s): w = s[R: R + one_word_len] R += one_word_len # R每次像右移一个单词的长度 if w not in words_cnt: # 结束前，出现个不知道哪里的单词，整个前面一片就废了 L = R cur_w_dic.clear() cur_w_num = 0 else: cur_w_dic[w] += 1 cur_w_num += 1 while cur_w_dic[w] \u003e words_cnt[w]: # 单词超量，移动L，更新计数 L_w = s[L : L + one_word_len] L += one_word_len cur_w_dic[L_w] -= 1 cur_w_num -= 1 if cur_w_num == word_cnt: # 满足条件，结果赋值 res.append(L) return res ","date":"2021-07-12","objectID":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:5","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 滑动窗口","uri":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]