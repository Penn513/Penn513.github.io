[{"categories":["Linux"],"content":"perf_events is an event-oriented observability tool, which can help you solve advanced performance and troubleshooting functions","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"perf也被称为perf_events，是一个面向event的观察工具，可用于性能剖析或内核故障排查。perf是内核的一部分，随内核发布。 ","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:0","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"事件（Events）事件分类： Hardware Events: CPU performance monitoring counters. Software Events: These are low level events based on kernel counters. For example, CPU migrations, minor faults, major faults, etc. Kernel Tracepoint Events: This are static kernel-level instrumentation points that are hardcoded in interesting and logical places in the kernel. User Statically-Defined Tracing (USDT): These are static tracepoints for user-level programs and applications. Dynamic Tracing: Software can be dynamically instrumented, creating events in any location. For kernel software, this uses the kprobes framework. For user-level software, uprobes. Timed Profiling: Snapshots can be collected at an arbitrary frequency, using perf record -FHz. This is commonly used for CPU usage profiling, and works by creating custom timed interrupt events. # perf list List of pre-defined events (to be used in -e): cpu-cycles OR cycles [Hardware event] instructions [Hardware event] cache-references [Hardware event] cache-misses [Hardware event] branch-instructions OR branches [Hardware event] branch-misses [Hardware event] bus-cycles [Hardware event] stalled-cycles-frontend OR idle-cycles-frontend [Hardware event] stalled-cycles-backend OR idle-cycles-backend [Hardware event] ref-cycles [Hardware event] cpu-clock [Software event] task-clock [Software event] page-faults OR faults [Software event] context-switches OR cs [Software event] cpu-migrations OR migrations [Software event] minor-faults [Software event] major-faults [Software event] alignment-faults [Software event] emulation-faults [Software event] L1-dcache-loads [Hardware cache event] L1-dcache-load-misses [Hardware cache event] L1-dcache-stores [Hardware cache event] [...] rNNN [Raw hardware event descriptor] cpu/t1=v1[,t2=v2,t3 ...]/modifier [Raw hardware event descriptor] (see 'man perf-list' on how to encode it) mem:\u003caddr\u003e[:access] [Hardware breakpoint] probe:tcp_sendmsg [Tracepoint event] [...] sched:sched_process_exec [Tracepoint event] sched:sched_process_fork [Tracepoint event] sched:sched_process_wait [Tracepoint event] sched:sched_wait_task [Tracepoint event] sched:sched_process_exit [Tracepoint event] [...] # perf list | wc -l 657 ","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:1","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"示例最近遇到个问题，程序的所有线程都被绑到0核上，但运行时并未使用taskset绑核。linux的绑核是通过系统调用syscalls:sys_enter_sched_setaffinity，进而考虑使用perf跟踪该系统调用，查看调用栈。 # 开启事件跟踪 perf record -g -e \"syscalls:sys_enter_sched_setaffinity\" -a # 另开启一个session，运行程序 # 通过Ctrl+c结束perf，在当前路径生成perf.data # 查看调用栈 perf script ","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:2","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"命令列出事件Listing Events # Listing all currently known events: perf list # Listing sched tracepoints: perf list 'sched:*' 计数事件Counting Events # CPU counter statistics for the specified command: perf stat command # Detailed CPU counter statistics (includes extras) for the specified command: perf stat -d command # CPU counter statistics for the specified PID, until Ctrl-C: perf stat -p PID # CPU counter statistics for the entire system, for 5 seconds: perf stat -a sleep 5 # Various basic CPU statistics, system wide, for 10 seconds: perf stat -e cycles,instructions,cache-references,cache-misses,bus-cycles -a sleep 10 # Various CPU level 1 data cache statistics for the specified command: perf stat -e L1-dcache-loads,L1-dcache-load-misses,L1-dcache-stores command # Various CPU data TLB statistics for the specified command: perf stat -e dTLB-loads,dTLB-load-misses,dTLB-prefetch-misses command # Various CPU last level cache statistics for the specified command: perf stat -e LLC-loads,LLC-load-misses,LLC-stores,LLC-prefetches command # Using raw PMC counters, eg, counting unhalted core cycles: perf stat -e r003c -a sleep 5 # PMCs: counting cycles and frontend stalls via raw specification: perf stat -e cycles -e cpu/event=0x0e,umask=0x01,inv,cmask=0x01/ -a sleep 5 # Count syscalls per-second system-wide: perf stat -e raw_syscalls:sys_enter -I 1000 -a # Count system calls by type for the specified PID, until Ctrl-C: perf stat -e 'syscalls:sys_enter_*' -p PID # Count system calls by type for the entire system, for 5 seconds: perf stat -e 'syscalls:sys_enter_*' -a sleep 5 # Count scheduler events for the specified PID, until Ctrl-C: perf stat -e 'sched:*' -p PID # Count scheduler events for the specified PID, for 10 seconds: perf stat -e 'sched:*' -p PID sleep 10 # Count ext4 events for the entire system, for 10 seconds: perf stat -e 'ext4:*' -a sleep 10 # Count block device I/O events for the entire system, for 10 seconds: perf stat -e 'block:*' -a sleep 10 # Count all vmscan events, printing a report every second: perf stat -e 'vmscan:*' -a -I 1000 性能剖析Profiling # Sample on-CPU functions for the specified command, at 99 Hertz: perf record -F 99 command # Sample on-CPU functions for the specified PID, at 99 Hertz, until Ctrl-C: perf record -F 99 -p PID # Sample on-CPU functions for the specified PID, at 99 Hertz, for 10 seconds: perf record -F 99 -p PID sleep 10 # Sample CPU stack traces (via frame pointers) for the specified PID, at 99 Hertz, for 10 seconds: perf record -F 99 -p PID -g -- sleep 10 # Sample CPU stack traces for the PID, using dwarf (dbg info) to unwind stacks, at 99 Hertz, for 10 seconds: perf record -F 99 -p PID --call-graph dwarf sleep 10 # Sample CPU stack traces for the entire system, at 99 Hertz, for 10 seconds (\u003c Linux 4.11): perf record -F 99 -ag -- sleep 10 # Sample CPU stack traces for the entire system, at 99 Hertz, for 10 seconds (\u003e= Linux 4.11): perf record -F 99 -g -- sleep 10 # If the previous command didn't work, try forcing perf to use the cpu-clock event: perf record -F 99 -e cpu-clock -ag -- sleep 10 # Sample CPU stack traces for a container identified by its /sys/fs/cgroup/perf_event cgroup: perf record -F 99 -e cpu-clock --cgroup=docker/1d567f4393190204...etc... -a -- sleep 10 # Sample CPU stack traces for the entire system, with dwarf stacks, at 99 Hertz, for 10 seconds: perf record -F 99 -a --call-graph dwarf sleep 10 # Sample CPU stack traces for the entire system, using last branch record for stacks, ... (\u003e= Linux 4.?): perf record -F 99 -a --call-graph lbr sleep 10 # Sample CPU stack traces, once every 10,000 Level 1 data cache misses, for 5 seconds: perf record -e L1-dcache-load-misses -c 10000 -ag -- sleep 5 # Sample CPU stack traces, once every 100 last level cache misses, for 5 seconds: perf record -e LLC-load-misses -c 100 -ag -- sleep 5 # Sample on-CPU kernel instructions, for 5 seconds: perf record -e cycles:k -a -- sleep 5 # Sample on-CPU user instructions, for 5 seconds: perf record -e cycle","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:3","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"参考https://www.brendangregg.com/perf.html ","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:4","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Data Structures and Algorithms"],"content":"数据排列具有单调性的栈。","date":"2021-07-12","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["Data Structures and Algorithms"],"content":"性质 单调递减栈，能表示入栈元素左边第一个比它大的元素。入栈表明本身比栈顶小，出栈表面本身比栈顶大； 单调递增栈，能表示入栈元素左边第一个比它小的元素。入栈表明本身比栈顶大，出栈表面本身比栈顶小； ","date":"2021-07-12","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 接雨水https://leetcode-cn.com/problems/trapping-rain-water/ 接雨水\r class Solution: def trap(self, height: List[int]) -\u003e int: if len(height) == 0: return 0 sumArea = 0 stack = [] for right in range(len(height)): while stack and height[stack[-1]] \u003c height[right]: if len(stack) \u003e= 2: bottom = stack.pop() left = stack[-1] waterHeight = min(height[right], height[left]) - height[bottom] waterWidth = right - left - 1 currArea = waterHeight*waterWidth sumArea += currArea else: stack.pop() stack.append(right) return sumArea ","date":"2021-07-12","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["Data Structures and Algorithms"],"content":"例题 2 - 股票价格跨度https://leetcode-cn.com/problems/online-stock-span/ 股票跨度\r 股票跨度-单调递减栈\r class StockSpanner: def __init__(self): self.stack = [] def next(self, price: int) -\u003e int: if not self.stack or self.stack[-1][0] \u003e price: self.stack.append((price, 1)) return 1 ans = 1 while self.stack and self.stack[-1][0] \u003c= price: bottom = self.stack.pop() ans += bottom[1] self.stack.append((price, ans)) return ans # Your StockSpanner object will be instantiated and called as such: # obj = StockSpanner() # param_1 = obj.next(price) ","date":"2021-07-12","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"}]